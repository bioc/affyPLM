%\VignetteIndexEntry{affyPLM: the "threestep" function}
%\VignettePackage{affyPLM}
\documentclass[12pt]{article}
\usepackage{amsmath,pstricks}
\usepackage{hyperref}
\usepackage[authoryear,round]{natbib}

\textwidth=6.2in
\textheight=8.5in
%\parskip=.3cm
\oddsidemargin=.1in
\evensidemargin=.1in
\headheight=-.3in

\newcommand{\scscst}{\scriptscriptstyle}
\newcommand{\scst}{\scriptstyle}
\author{Ben Bolstad \\ {\tt bolstad@stat.berkeley.edu}}
\begin{document}
\title{affyPLM: the "threestep" function}
\maketitle
\tableofcontents
\section{Introduction}

This document describes the threestep function which is part of the affyPLM package. The threestep function is an alternative method of computing expression measures (which can also be generated using {\it expresso}, {\it rma()} and other functions from the {\it affy} package). In the threestep framework an expression measure consists of threesteps: background/signal adjustment, normalization and then summarization. One important thing to notice is that all expression measures returned by {\it threestep} are all in the $\log_2$ scale.

After starting R, the package should be loaded using
<<echo=F,results=hide>>=
library(affyPLM)
@
this will load affyPLM as well as the affy package and its dependencies.

\section{Using the threestep function}

The simplest method  of calling the {\it threestep} function is to call it with no arguments beyond an AffyBatch.
<<eval=FALSE>>=
data(Dilution)
eset <- threestep(Dilution)
@
this will compute the conventional RMA expression measure. 

But we can go beyond this by altering any of the threesteps. This can be done using the three parameters {\it background.method, normalize.method, summary.method}. For example
<<eval=FALSE>>=
eset <- threestep(Dilution, background.method = "MASIM",
	normalize.method="quantile",summary.method="tukey.biweight")
@
computes an expression measure where we background correct/signal adjust by breaking the array into grids doing a location dependent adjustment, then subtracting the "ideal mismatch" from the perfect match. Normalization is done using the quantile normalization method and then summarization using a 1-step Tukey Biweight.

An even more unconventional expression measure is to background correct/signal adjust by subtracting the ideal mismatch, carry out no normalization, then summarize by taking the 2nd largest PM (which in this case will really be the largest PM after subtracting the ideal mismatch).

<<eval=FALSE>>=
eset <- threestep(Dilution, background.method = "IdealMM",
	normalize="quantile",summary.method="log.2nd.largest")
@


\section{Methods available in {\it threestep}}

The following tables outline the methods that are available for each of the threesteps.
\begin{center}
\begin{tabular}{lll} \hline
\multicolumn{3}{c}{Background methods} \\ \hline
Option & Name & Description \\ \hline
{\tt RMA.2} (default) & RMA convolution model background&  \\
{\tt RMA.1} & RMA convolution model background & \\
{\tt MAS} & MAS 5.0 location dependent background & \\
{\tt IdealMM} & Ideal Mismatch& \\
{\tt MASIM} & MAS 5 and Ideal Mismatch& \\ \hline
\end{tabular}
\end{center}

\begin{center}
\begin{tabular}{lll} \hline
\multicolumn{3}{c}{Normalization methods} \\ \hline
Option & Name & Description \\  \hline
{\tt quantile} (default)& Quantile normalization & \\ 
{\tt scaling} & scaling normalization & \\ \hline
\end{tabular}
\end{center}

\begin{center}
\begin{tabular}{lll} \hline
\multicolumn{3}{c}{Summarization methods} \\ \hline
Option & Name & Description \\  \hline
{\tt median.polish} (default)& Median polish& \\
{\tt tukey.biweight} & 1 step tukey biweight& \\
{\tt average.log} & Average of Logs& \\
{\tt log.average} & Log of Average & \\
{\tt median.log} & Median of Logs& \\
{\tt log.median} & Log of Median & \\
{\tt log.2nd.largest} & 2nd largest PM& \\
{\tt lm} & Linear Model& \\
{\tt rlm} & Robust Linear Model& \\ \hline
\end{tabular}
\end{center}





%\bibliographystyle{plainnat}
%\bibliography{affyPLM}

\end{document}

